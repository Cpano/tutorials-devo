<!--========================================CALENDAR ICON========================================-->
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style"
    onload="this.onload=null;this.rel='stylesheet'">
<link rel="stylesheet" href="https://cpano.github.io/tutorials-devo/public/css/TutorialsStyles.css">

<!--========================================HEADER========================================-->
<!-- CC01v0 -->
<section style="background-image:url(/a/devo/images/cc01-weblogic-hero-banner.jpg);" class="cc01 cc01v0  txtlight cpad">
    <div class="cc01w1 cwidth">

        <h2>Application Infrastructure</h2>
        <p>Oracle Cloud Infrastructure (OCI) allows different deployment models to be applied within a shared network
            and deployed using the same Infrastructure-as-Code methods. </p>

        <div style="display: flex; color: white;">
            <p class="page__date" style="margin-right: 25px;"><strong><i class="fas fa-user fa-calendar-alt"
                        aria-hidden="true"></i>
                    Author: </strong>
                Malte Menkhoff
            </p>

            <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong>
                <time>December 6, 2021</time>
            </p>

        </div>

    </div>
</section>
<!-- /CC01v0 -->
<!--========================================END BLOCK CODE STYLES========================================-->

<!-- F19v0 -->
<section class="f19 f19v0 cpad">
    <div class="f19w1 cwidth">
        <div class="f19w2 f19-2col">
            <div class="f19col f19side">
                <!-- S20v0 -->
                <section class="s20 s20v0 cpad" data-ocomid="s20" data-trackas="s20">
                    <div class="s20w1 cwidth">
                        <div class="col-w1">

                            <h3>About Malte Menkhoff</h3>

                            <!--Social Icons-->
                            <div class="author__urls-wrapper" style="margin-bottom: 15px;">
                                <ul class="author__urls social-icons">
                                    <li>
                                        <a href="https://github.com/kubemen" itemprop="sameAs"
                                            rel="nofollow noopener noreferrer" target="_blank">
                                            <i class="fab fa-fw fa-github" aria-hidden="true"></i><span
                                                class="label">GitHub</span>
                                        </a>
                                    </li>
                                </ul>
                            </div><br><br>
                            <!-- End Social Icons-->
                            <p>Malte is a passioned solution architect and is supporting customers in the DACH region in
                                migrating to OCI.</p>

                            <p><strong>More tutorials from this author: <br> </strong> <span class="tags">

                                    <a class="animated-link tag2" href="#">Deploy Apache Superset with MySQL Database
                                        Service on Oracle Cloud Infrastructure</a><br>

                                    <a class="animated-link tag2" href="
                                        /tutorials/oci-iac-framework/getting-started-with-oci-intro">Getting
                                        Started with Oracle Cloud Infrastructure (OCI)</a><br>

                                    <a class="animated-link tag2"
                                        href="
                                        /tutorials/oci-iac-framework/getting-started-with-oci-step-1-provider">Automating
                                        OCI with Terraform</a><br>

                                    <a class="animated-link tag2" href="
                                        /tutorials/oci-iac-framework/getting-started-with-oci-step-2-base">Service
                                        Delivery Framework</a><br>

                                    <a class="animated-link tag2"
                                        href="
                                        /tutorials/oci-iac-framework/getting-started-with-oci-step-3-database-infrastructure">Database
                                        Infrastructure</a><br>

                                    <a class="animated-link tag2"
                                        href="
                                        /tutorials/oci-iac-framework/getting-started-with-oci-step-5-workload-deployment">Workload
                                        Deployment</a><br>

                                    <a class="animated-link tag2"
                                        href="
                                        /tutorials/oci-iac-framework/getting-started-with-oci-step-6-governance">Governance</a><br>

                                    <a class="animated-link tag2" href=" /tutorials/oci-iac-framework/">Oracle Cloud
                                        Infrastructure IaC
                                        Framework</a><br>

                                </span>
                            </p>

                            <!--Tags-->
                            <h3>Tags</h3>
                            <p> <span class="tags">
                                    <a class="animated-link tag" href="#">open-source</a>
                                    <a class="animated-link tag" href="#">terraform</a>
                                    <a class="animated-link tag" href="#">iac</a>
                                    <a class="animated-link tag" href="#">devops</a>
                                    <a class="animated-link tag" href="#">get-started</a>
                                </span>
                            </p>

                            <h3></h3>
                            <a href="https://developer.oracle.com/tutorials" '>
                                <p class="page__date" style="margin-right: 25px;"><strong>
                                        Back to tutorials 
                                    </strong>
                                </p>
                            </a>

                        </div>
                    </div>
                </section>
                <!-- /S20v0 -->
            </div>
            <!-- SET UP -->
            <main class="f19col f19main">
                <!-- cc01v0 -->

                <section class="cc01 cc01v0 cpad" id="link1">
                    <div class="cc01w1 cwidth">

                        <h2>Welcome!</h2>

       
            <img loading="lazy"
                src="https://cool.devo.build/tutorials/oci-iac-framework/assets/landing-zone.png"
                data-original="https://cool.devo.build/tutorials/oci-iac-framework/assets/landing-zone.png"
                data-at2x="https://cool.devo.build/tutorials/oci-iac-framework/assets/landing-zone@2x.png"
                alt="OCLOUD landing zone" title="OCLOUD landing zone">


        <p>Oracle Cloud Infrastructure (OCI) allows different deployment models to be applied within a shared network
            and deployed using the same Infrastructure-as-Code methods. When setting up our operation, we distinguish
            between core and orchestration service API. Core services represent the physical infrastructure in our data
            center, and orchestration services refer to software that runs outside the core service portfolio, interacts
            with the application code, and manipulates the behavior of virtual instances. Application developers and
            service operators need to delineate the following four infrastructure deployment models when designing a
            multi-server architecture:</p>

        <ul>
            <li>Dedicated Server — Virtual Machines (VM) or bare metal server that maintain stateful communication
                interfaces on layer three.</li>
            <li>Elastic Compute cluster — One or more VM that scales automatically and maintain a stateless
                communication interface on layer three.</li>
            <li>Container Cluster — One or more dedicated server that host lightweight stand-alone, executable user
                space images including code, runtime, system tools, system libraries, settings to run on a linux kernel.
            </li>
            <li>Functions, ephemeral, single purpose, self contained, stateless container without API surface, invoked
                via network protocols like HTTP.</li>
        </ul>

        <p>While public cloud providers offer these instance types as products, in OCI we define logical resources —
            including the respective orchestrator. We can rely on managed services for open source orchestrators, or
            choose commercial third-party offerings. Either way, we invoke an orchestrator, writing modules for the
            resource manager. Here we will focus on these three different models:</p>

        <picture class="aligncenter">
            <source srcset="https://cool.devo.build/tutorials/oci-iac-framework/assets/host_node_container.png 1x" />
            <img loading="lazy" src="https://cool.devo.build/tutorials/oci-iac-framework/assets/host_node_container.png"
                data-original="https://cool.devo.build/tutorials/oci-iac-framework/assets/host_node_container.png"
                data-at2x="https://cool.devo.build/tutorials/oci-iac-framework/assets/host_node_container@2x.png"
                alt="Overview of Host, Node and Container Deployment Models in OCI"
                title="Overview of Host, Node and Container Deployment Models in OCI" />
        </picture>

        <ol>
            <li>The <strong>Host model</strong> is the one most known from on-premise environments: On a dedicated
                physical machine, Virtual Machines (VMs) can be deployed that run stateless or stateful applications.
                OCI offers both ways here:
                <ul>
                    <li>You can deploy a bare metal host, install the hypervisor and deploy the VMs on top of it. Here,
                        you are responsible for the VMs and the hypervisor layer as well as the Operating System (O/S)
                        of the bare metal host. You will have full root access to the O/S of the bare metal server and
                        it will be inside a Virtual Cloud Network (VCN) that you own.</li>
                    <li>You can deploy a Dedicated VM Host and deploy the VMs on top of it. This is the approach that we
                        use here: You can use Terraform to fully deploy both the Dedicated VM Host as well as the VMs on
                        top of it. Each VM will be instantiated with its own Virtual Network Interface Card (VNIC) which
                        can be individually placed into VCNs and subnets that you own. The Dedicated VM Host itself will
                        be in full control by Oracle, you won’t have any O/S access to it and the Dedicated VM Host
                        won’t be placed in any VCN.</li>
                </ul>

                <p>You can use tools like <strong>Packer</strong> to first build a custom image with all applications
                    and data you need on your VMs before applying Terraform to instantiate the VMs. The <code
                        class="language-plaintext highlighter-rouge">cloud-init</code> option of Terraform gives the
                    opportunity to apply a shell script on the instantiated VMs to add individual data or installations
                    immediately after the instantiation.</p>

                <p>Here, the shell script is added as a base64-encoded attribute to the resource definition of the
                    instance. Through metadata key-value pairs, Terraform can pass parameters to the instance that can
                    be used inside the cloud-init shell script to parameterize the actual shell execution.</p>

                <p>The Terraform stack consists of a dedicatedHost.tf file which can be used to create a Dedicated VM
                    Host. By default, this code is commented out because many demo-tenants do not allow the creation of
                    Dedicated VM Hosts by its Service Limits. It can easily be activated by removing the comments
                    start/end lines.</p>
            </li>
            <li>
                <p>The <strong>Node model</strong> applies the cloud principle to adapt the number of available nodes to
                    the current amount of workload. Here we have primary workloads running that control secondary
                    workloads on top which will be scaled in and out based on on-demand capacity rather than capacity
                    from a Dedicated VM Host in order to optimize the costs. The secondary workloads should be stateless
                    in nature since scaling in means that those nodes might be terminated by the Cloud Control at any
                    time if the overall workload would be sufficiently executed by less nodes.</p>

                <p>OCI has the following artifacts to create this scenario, which can be fully deployed by Terraform:
                </p>

                <ul>
                    <li>
                        <p>An Instance Configuration that acts as the blueprint for the pool of secondary workloads VMs.
                            Here you define
                            - A Custom Image that should be used (can be built using <strong>Packer</strong> and you can
                            use <code class="language-plaintext highlighter-rouge">cloud-init</code> provider for
                            further work).
                            - The Shape of the pool instances (e.g. <em>VM.Standard2.1</em> which means a 1 OCPU Intel
                            X7 VM with network-attached storage).
                            - The public part of the <strong>ssh</strong> key pair to access the O/S of the instance.
                        </p>
                    </li>
                    <li>
                        <p>The Instance Pool object refers to an Instance Configuration and adds information about in
                            which Availability Domain it will be in, as well as in which subnet the instance pool’s
                            instances’ VNICs should be placed. Furthermore, you define how many VMs should be started.
                            You can add a load balancer to the instance pool definition in a way that any created
                            instances inside the pool will be part of this load balancer’s backend set, so that incoming
                            requests are forwarded to the instance pool instances e.g. in a round-robin-manner. Load
                            balancers also support cookie-based session stickiness in case this is needed by stateful
                            applications running in the instance pool instances.</p>
                    </li>
                    <li>
                        <p>The Autoscaling Configuration refers to an Instance Pool and adds policies to when new
                            instances should be automatically added and when instances should be removed. You define the
                            incremental and decremental step size (numbers of instances to be added or removed when a
                            scale-in or scale-out event occurs) as well as the minimum and maximum total number of
                            instances. Two autoscaling policies are supported:</p>

                        <ul>
                            <li>
                                <p>Schedule-based Autoscaling: Here the scaling-out and scaling-in rules are defined
                                    based on fixed schedules similar to definitions in cron jobs. This is feasible, if
                                    regular workload peaks are to be expected like loading data into a Data Warehouse or
                                    providing Analytic reporting at certain times during a day, week or month.</p>
                            </li>
                            <li>
                                <p>Metrics-based Autoscaling: Here the scaling-out and scaling-in rules are based on
                                    overall instance pool metrics that the instances report using agents to the Cloud
                                    Control. OCI allows the following metrics to be used here:</p>

                                <ul>
                                    <li>CPU Utilization (in percent)</li>
                                    <li>Memory Utilization (in percent)</li>
                                </ul>
                            </li>
                            <li>
                                <p>In the Autoscaling Configuration you define the percent threshold value above which
                                    the pool will scale out (add an instance or instances if the maximum number is not
                                    yet reached) and the percent threshold value underneath which the pool will scale in
                                    (terminate an instance or instances if the minimum number is not yet reached).</p>
                            </li>
                        </ul>
                    </li>
                </ul>

                <p>In the scenario, we trigger a 100% CPU utilization process in each new instance pool instance upon
                    instance creation (using <code class="language-plaintext highlighter-rouge">cloud-init</code> that
                    lasts for a number of minutes that the user can define as part of the Terraform stack definition as
                    a variable. So we can optionally demonstrate the scaling-in and scaling-out according to an
                    CPU-utilization based auto-scaling policy.</p>

                <p>Further, we deploy an httpd server along with a static page (showing a timestamp for the instance
                    creation) on each instance pool instance. This stateless “application” is exposed to the public
                    internet by a load balancer, so you can see the round-robin-fashioned forwarding of requests to the
                    instance pool instances by reloading the page in the browser. The corresponding public load balancer
                    endpoint is displayed a part of the Terraform out parameters. In this stack, the load balancer
                    exposes the “application” with https, using a self-signed certificate that is also created inside
                    the Terraform stack.</p>
            </li>
            <li>
                <p>The <strong>Container model</strong> is the preferred cloud model for stateless applications like
                    Functions. OCI offers a fully managed <strong>Kubernetes</strong> Cluster, the OCI Container Engine
                    (OKE). Again, this can be fully deployed using Terraform.</p>

                <p>OKE consists of:</p>

                <ul>
                    <li>The Kubernetes Cluster which provides the Kubernetes API endpoint as well as the Scheduler and
                        Controller Manager. These components are fully managed by Oracle and visible to the customer
                        only using the Kubernetes API (e.g. by using <strong>kubectl</strong> or by deploying
                        <em>Helm</em> charts). The customer doesn’t have O/S access to this instance and also doesn’t
                        have to pay for it. This component is free of charge.
                    </li>
                    <li>The Kubernetes Node Pool that contains the worker nodes. The customer has full root access using
                        <em>ssh</em> and has to pay for these VMs. The charges are the regular charges for Linux VMs of
                        the respective shapes – there is no surcharge for their role being a Kubernetes worker node.
                    </li>
                    <li>further elements are added and terminated according to Kubernetes deployments. E.g. when
                        deploying a Load Balancer service to a Kubernetes cluster like</li>
                </ul>

                <div class="language-console highlighter-rouge">
                    <div class="highlight">
                        <pre class="highlight"><code><span class="gp">  $</span><span class="w"> </span>kubectl expose deployment myapplication <span class="nt">--type</span><span class="o">=</span>LoadBalancer <span class="nt">--name</span><span class="o">=</span>myapplicationservice
</code></pre>
                    </div>
                </div>

                <p>An OCI Load Balancer is automatically deployed and configured with the worker nodes in its backend
                    set.</p>
            </li>
        </ol>

        <p>When the cluster is ready, the <code class="language-plaintext highlighter-rouge">.kube/config</code> file
            (which contains the network details like the Kubernetes Cluster’s API endpoint’s IP address and the
            authorization certificate) can be downloaded to a client using the following OCI Command Line Interface (OCI
            CLI) command:</p>

        <div class="language-console highlighter-rouge">
            <div class="highlight">
                <pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>oci ce cluster create-kubeconfig <span class="nt">--cluster-id</span> ocid1.cluster.oc1.eu-frankfurt-1.aaaaathekubernetesclusterocidlqs27a <span class="nt">--file</span> <span class="nv">$HOME</span>/.kube/config <span class="nt">--region</span> eu-frankfurt-1 <span class="nt">--token-version</span> 2.0.0 
<span class="gp">export KUBECONFIG=$</span>HOME/.kube/config
</code></pre>
            </div>
        </div>

        <p>The Terraform stack creates also an Kubernetes Cluster along with a worker node pool, the contents of the
            <code class="language-plaintext highlighter-rouge">.kube/config</code> file can be directly taken by a
            corresponding parameter of the Terraform Output.
        </p>

        <p>Then, the client can e.g apply <strong>kubectl</strong> to inspect, create and destroy Kubernetes artifacts:
        </p>

        <div class="language-console highlighter-rouge">
            <div class="highlight">
                <pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>kubectl get nodes,pods
<span class="go">NAME               STATUS   ROLES   AGE     VERSION
node/10.0.10.166   Ready    node    7h11m   v1.19.7

NAME                                 READY   STATUS    RESTARTS   AGE
pod/myapplication-588cf6ff66-cq684   1/1     Running   0          6h13m
pod/myapplication-588cf6ff66-hwtgd   1/1     Running   0          6h13m
pod/myapplication-588cf6ff66-q4228   1/1     Running   0          6h15m
</span></code></pre>
            </div>
        </div>

        <p>OCI also offers a registry service (the OCI registry, OCIR) where container images can be stored and
            retrieved to be deployed to the Kubernetes cluster. OCIR allows registries both being publicly available
            (free access to anyone) or privately (downloading images prerequisites presenting a SWIFT-compliant API Key,
            a so called <strong>OCI Auth Token</strong> that is created individually for each OCI User).</p>

        <p>Besides deploying Kubernetes artifacts like pods, deployments, services, replicasets etc. using a
            <strong>kubectl</strong> client, Terraform provides a Kubernetes provider in order to deploy these artifacts
            as part of the terraform apply process. The <code
                class="language-plaintext highlighter-rouge">okeServiceDeployment.tf</code> shows the steps to take
            here:
        </p>

        <ol>
            <li>Get the OKE Cluster’s config file and extract the CA certificate as well as the OCI CLI command (along
                with the necessary arguments) to create an ExecCredential. This OCI CLI command is executed, so
                Terraform can authenticate to the Kubernetes API endpoint for further operations.</li>
            <li>Create a new namespace in Kubernetes.</li>
            <li>Define further resources like <code
                    class="language-plaintext highlighter-rouge">kubernetes_service</code> to deploy artifacts.
                Kubernetes artifacts are defined by yaml documents and those Terraform resources basically reformat
                these yaml documents to the HashiCorp Configuration Language (HCL) format.</li>
        </ol>

        <p>In this example stack, we deploy a standard NGINX server to the new generated Kubernetes Cluster. We take the
            standard NGINX image from the official Docker registry, but you can also deploy your own pods from docker
            images that are stored e.g. in the OCI registry (OCIR).</p>

        <p>We deploy this NGINX server as a <code class="language-plaintext highlighter-rouge">kubernetes_service</code>
            with “Load Balancer” as the type using Terraform. The advantage of using Terraform instead of a local
            <strong>kubectl</strong> client for deploying Kubernetes services is, that those services are also being
            deleted when destroying the Terraform stack. This is important because deploying a Kubernetes service with
            “Load Balancer” as type means that an OCI Load Balancer with the Kubernetes deployment of pods in its
            backend is created outside of the Kubernetes Cluster. So you need to delete the Kubernetes service first
            when destroying the Terraform stack in order to properly remove this load balancer.
        </p>

        <p>The complete network topology along with the compute instances, load balancers and Kubernetes resources that
            will be created by running this stack can be seen in this picture below:</p>

        <picture class="">
            <source
                srcset="https://cool.devo.build/tutorials/oci-iac-framework/assets/network_topology_app_stack.png 1x" />
            <img loading="lazy"
                src="https://cool.devo.build/tutorials/oci-iac-framework/assets/network_topology_app_stack.png"
                data-original="https://cool.devo.build/tutorials/oci-iac-framework/assets/network_topology_app_stack.png"
                data-at2x="https://cool.devo.build/tutorials/oci-iac-framework/assets/network_topology_app_stack@2x.png"
                alt="Network topology of the app stack" title="Network topology of the app stack" />
        </picture>

        <p>After the Terraform stack has been successfully applied, you should see the following Kubernetes artifacts
            (e.g. by using the cloud shell):</p>

        <div class="language-console highlighter-rouge">
            <div class="highlight">
                <pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>kubectl get pods,deployments,replicasets,services <span class="nt">--namespace</span> nginx
<span class="go">NAME                         READY   STATUS    RESTARTS   AGE
pod/nginx-5c48f8956d-84456   1/1     Running   0          41m
pod/nginx-5c48f8956d-wwq8s   1/1     Running   0          41m

NAME                    READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/nginx   2/2     2            2           41m

NAME                               DESIRED   CURRENT   READY   AGE
replicaset.apps/nginx-5c48f8956d   2         2         2       41m

NAME            TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)        AGE
service/nginx   LoadBalancer   10.96.113.223   152.70.173.212   80:32177/TCP   33m
</span></code></pre>
            </div>
        </div>

        <table>
            <tbody>
                <tr>
                    <td><a href="getting-started-with-oci-step-3-database-infrastructure">&lt; db-infra</a></td>
                    <td><a href="index">+</a></td>
                    <td><a href="getting-started-with-oci-step-5-workload-deployment">workload &gt;</a></td>
                </tr>
            </tbody>
        </table>
            </div>
                </section>
            </main>
        </div>
    </div>
</section>
<!-- /F19v0 -->